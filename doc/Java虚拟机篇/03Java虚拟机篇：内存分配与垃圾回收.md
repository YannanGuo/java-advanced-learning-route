# Java虚拟机篇：内存分配与垃圾回收

**关于作者**

>郭孝星，程序员，吉他手，主要从事Android平台基础架构方面的工作，欢迎交流技术方面的问题，可以去我的[Github](https://github.com/guoxiaoxing)提issue或者发邮件至guoxiaoxingse@163.com与我交流。

Java中有四种引用。

- 强引用：代码中普遍存在的，只要强引用还存在，垃圾收集器就不会回收掉被引用的对象。
- 软引用：SoftReference，用来描述还有用但是非必须的对象，当内存不足的时候回回收这类对象。
- 弱引用：WeakReference，用来描述非必须对象，弱引用的对象只能生存到下一次GC发生时，当GC发生时，无论内存是否足够，都会回收该对象。
- 虚引用：PhantomReference，一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用取得一个对象的引用，它存在的唯一目的是在这个对象被回收时可以收到一个系统通知。

可达性分析算法

>可达性分析算法通过一系列称为GC Roots的对象作为起始点，从这些节点从上向下搜索，搜索走过的路径称为引用链，当一个对象没有任何引用链
与GC Roots连接时就说明此对象不可用，也就是对象不可达。

GC Roots对象包括：

- 虚拟机栈中引用的对象（栈帧中的本地变量表）
- 方法去中类的静态属性引用的对象
- 方法区中常量引用的对象
- Native方法引用的对象

当对象与GC Roots之间没有任何引用链相连时，则它会被进行第一次标记并判断时候有必要执行finalize()方法，判断条件是：当对象没有覆盖finalize()方法或者已经执行过finalize()方法，则没有
必要执行finalize()方法。

当对象被判定有必要执行finalize()方法，则将该对象放在一个F-Queue的队列中，并在一个稍后由虚拟机建立的、低优先级的Finalizer线程中去触发finalize()方法，稍后GC将会对这个队列的对象再次
进行上述标记，如果在这次标记中还是没有查找到引用链，则它就会被回收。

要获取GC Roots节点就要去枚举GC Roots节点，但是这个枚举操作需要在能确保一致性的快照中进行，也就是要暂停一下系统的运行，不然对象引用关系随着系统运行不断发生变化，那这个枚举的结果的
准确性就不能得到保证，这也就是所谓的GC停顿。

但是GC也不是在任何地方会发生，GC只会在到达安全点后才会开始执行。对于安全点，我们需要考虑的另一个问题就是当GC发生时如果让所有线程（不包括JNI线程都跑到最近的安全点停下来。
现在的虚拟机多采用主动式中断的方式来做。

我们来解释上面提到的两个概念：

>安全点：Safepoint，指的是GC特定的停顿位置，这写位置以是否具有让程序长时间执行为筛选标准，符合长时间执行这一特征往往就是指令复用，例如：方法调用，循环跳转，异常跳转等。

>主动式中断：当GC需要中断线程时，并不会直接对线程直接操作，仅仅简单的设置一个标志，各个线程执行的时候主动地去轮询这个标志，发现中断的标志时就自己中断挂起。这些设置中断标志
的地方就是安全点所在的位置。



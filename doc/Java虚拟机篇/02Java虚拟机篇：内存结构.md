# Java虚拟机篇：Java虚拟机概述

**关于作者**

>郭孝星，非著名程序员，主要从事Android平台基础架构与中间件方面的工作，爱好广泛，技术栈主要涉及以下几个方面
>
>- Android/Linux
>- Java/Kotlin/JVM
>- Python
>- JavaScript/React/ReactNative
>- DataStructure/Algorithm
>
>文章首发于[Github](https://github.com/guoxiaoxing)，后续也会同步在[简书](http://www.jianshu.com/users/66a47e04215b/latest_articles)与
[CSDN](http://blog.csdn.net/allenwells)等博客平台上。文章中如果有什么问题，欢迎发邮件与我交流，邮件可发至guoxiaoxingse@163.com。

Java虚拟机在运行Java程序时会将它管理的内存划分为若干个不同的区域，这些区域有着各自的功能以及创建、销毁时间。如下图所示：

<img src="https://github.com/guoxiaoxing/java/raw/master/art/jvm/02/jvm_memory_structure.png"/>

方法区

>方法区：线程共享，用于存储已被虚拟机加载的类信息，常量，静态变量以及及时编译器编译后的戴拿等数据。

在Java虚拟机规范中，对方法去的要求比较宽松，可以和Java堆一样不需要连续的内存空间，可以选择固定大小或者扩展，还可以选择不实现垃圾收集。如果选择
实现垃圾收集，那么主要的回收目标在于针对常量池的回收以及类型的卸载。

方法区中有一部分称为运行时常量池，用于存放编译期生成的各种字面量和符号引用。

在Java虚拟机规范中，对该区域规定了一种异常情况：

- OutOfMemoryError：如果虚拟机栈是可以动态扩展的，当扩展时无法申请到足够的内存则抛出该异常。

虚拟机栈

>虚拟机栈：线程私有，生命周期与线程相同，虚拟机栈描述Java方法执行的内存模型，每个方法在执行时都会创建一个栈帧，栈帧用于存储局部变量表，操作数
栈，动态链接，方法出口等信息，每个方法从调用到结束就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

局部变量表存放了各种编译期可知的基本数据类型：

- boolean
- byte
- char
- short
- int
- float
- long
- double
- reference：对象引用，它不等同于对象本身，可能指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象的相关的位置。

在Java虚拟机规范中，对该区域规定了两种异常情况：

- StackOverFlowError：如果线程请求的栈深度大于虚拟机允许的深度，则抛出该异常。
- OutOfMemoryError：如果虚拟机栈是可以动态扩展的，当扩展时无法申请到足够的内存则抛出该异常。

本地方法栈

>本地方法栈：线程私有，它与虚拟机栈十分相似，相对于虚拟机栈为Java方法服务，本地方法栈为Native方法服务。

本地方法栈也同虚拟机栈一样规定了StackOverFlowError与OutOfMemoryError两种异常。

Java堆

>Java堆：线程共享，Java虚拟机管理的内存区域中最大的一块，在虚拟机启动时创建，该区域的作用是存放对象实例。

Java堆是垃圾收集器管理的主要区域，现在GC普遍采用分代收集算法，因此Java堆还可以细分为新生代与老年代。另外，Java堆可以处于物理上不连续的内存空间，只要
逻辑上连续就可以了。

在Java虚拟机规范中，对该区域规定了一种异常情况：

- OutOfMemoryError：如果虚拟机栈是可以动态扩展的，当扩展时无法申请到足够的内存则抛出该异常。

在Java虚拟机规范中，对该区域规定了一种异常情况：

- OutOfMemoryError：如果虚拟机栈是可以动态扩展的，当扩展时无法申请到足够的内存则抛出该异常。

程序计数器

>程序计数器：空间较小，每个线程私有，当前线程所执行字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器来选择下一条需要执行的字节码指令。
如果执行的是Java方法，则该计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法，则计数器的值为空。

